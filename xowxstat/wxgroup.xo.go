package xowxstat

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// WxGroup represents a row from 'wx_group'.
type WxGroup struct {
	GroupID      int            `json:"group_id"`      // group_id
	Name         string         `json:"name"`          // name
	Comment      sql.NullString `json:"comment"`       // comment
	ActivePeriod int            `json:"active_period"` // active_period
	QuietPeriod  int            `json:"quiet_period"`  // quiet_period
	ActiveNum    int            `json:"active_num"`    // active_num
	QuietNum     int            `json:"quiet_num"`     // quiet_num
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the WxGroup exists in the database.
func (wg *WxGroup) Exists() bool {
	return wg._exists
}

// Deleted returns true when the WxGroup has been marked for deletion from
// the database.
func (wg *WxGroup) Deleted() bool {
	return wg._deleted
}

// Insert inserts the WxGroup to the database.
func (wg *WxGroup) Insert(ctx context.Context, db DB) error {
	switch {
	case wg._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case wg._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO wx_group (` +
		`group_id, name, comment, active_period, quiet_period, active_num, quiet_num` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)`
	// run
	logf(sqlstr, wg.GroupID, wg.Name, wg.Comment, wg.ActivePeriod, wg.QuietPeriod, wg.ActiveNum, wg.QuietNum)
	if _, err := db.ExecContext(ctx, sqlstr, wg.GroupID, wg.Name, wg.Comment, wg.ActivePeriod, wg.QuietPeriod, wg.ActiveNum, wg.QuietNum); err != nil {
		return logerror(err)
	}
	// set exists
	wg._exists = true
	return nil
}

// Update updates a WxGroup in the database.
func (wg *WxGroup) Update(ctx context.Context, db DB) error {
	switch {
	case !wg._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case wg._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE wx_group SET ` +
		`name = $1, comment = $2, active_period = $3, quiet_period = $4, active_num = $5, quiet_num = $6 ` +
		`WHERE group_id = $7`
	// run
	logf(sqlstr, wg.Name, wg.Comment, wg.ActivePeriod, wg.QuietPeriod, wg.ActiveNum, wg.QuietNum, wg.GroupID)
	if _, err := db.ExecContext(ctx, sqlstr, wg.Name, wg.Comment, wg.ActivePeriod, wg.QuietPeriod, wg.ActiveNum, wg.QuietNum, wg.GroupID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the WxGroup to the database.
func (wg *WxGroup) Save(ctx context.Context, db DB) error {
	if wg.Exists() {
		return wg.Update(ctx, db)
	}
	return wg.Insert(ctx, db)
}

// Upsert performs an upsert for WxGroup.
func (wg *WxGroup) Upsert(ctx context.Context, db DB) error {
	switch {
	case wg._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO wx_group (` +
		`group_id, name, comment, active_period, quiet_period, active_num, quiet_num` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)` +
		` ON CONFLICT (group_id) DO ` +
		`UPDATE SET ` +
		`name = EXCLUDED.name, comment = EXCLUDED.comment, active_period = EXCLUDED.active_period, quiet_period = EXCLUDED.quiet_period, active_num = EXCLUDED.active_num, quiet_num = EXCLUDED.quiet_num `
	// run
	logf(sqlstr, wg.GroupID, wg.Name, wg.Comment, wg.ActivePeriod, wg.QuietPeriod, wg.ActiveNum, wg.QuietNum)
	if _, err := db.ExecContext(ctx, sqlstr, wg.GroupID, wg.Name, wg.Comment, wg.ActivePeriod, wg.QuietPeriod, wg.ActiveNum, wg.QuietNum); err != nil {
		return err
	}
	// set exists
	wg._exists = true
	return nil
}

// Delete deletes the WxGroup from the database.
func (wg *WxGroup) Delete(ctx context.Context, db DB) error {
	switch {
	case !wg._exists: // doesn't exist
		return nil
	case wg._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM wx_group ` +
		`WHERE group_id = $1`
	// run
	logf(sqlstr, wg.GroupID)
	if _, err := db.ExecContext(ctx, sqlstr, wg.GroupID); err != nil {
		return logerror(err)
	}
	// set deleted
	wg._deleted = true
	return nil
}

// WxGroupByName retrieves a row from 'wx_group' as a WxGroup.
//
// Generated from index 'idx_wx_group_name'.
func WxGroupByName(ctx context.Context, db DB, name string) ([]*WxGroup, error) {
	// query
	const sqlstr = `SELECT ` +
		`group_id, name, comment, active_period, quiet_period, active_num, quiet_num ` +
		`FROM wx_group ` +
		`WHERE name = $1`
	// run
	logf(sqlstr, name)
	rows, err := db.QueryContext(ctx, sqlstr, name)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*WxGroup
	for rows.Next() {
		wg := WxGroup{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&wg.GroupID, &wg.Name, &wg.Comment, &wg.ActivePeriod, &wg.QuietPeriod, &wg.ActiveNum, &wg.QuietNum); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &wg)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// WxGroupByGroupID retrieves a row from 'wx_group' as a WxGroup.
//
// Generated from index 'wx_group_group_id_pkey'.
func WxGroupByGroupID(ctx context.Context, db DB, groupID int) (*WxGroup, error) {
	// query
	const sqlstr = `SELECT ` +
		`group_id, name, comment, active_period, quiet_period, active_num, quiet_num ` +
		`FROM wx_group ` +
		`WHERE group_id = $1`
	// run
	logf(sqlstr, groupID)
	wg := WxGroup{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, groupID).Scan(&wg.GroupID, &wg.Name, &wg.Comment, &wg.ActivePeriod, &wg.QuietPeriod, &wg.ActiveNum, &wg.QuietNum); err != nil {
		return nil, logerror(err)
	}
	return &wg, nil
}
